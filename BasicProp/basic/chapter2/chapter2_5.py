# encoding: utf-8
import math

# 整数的关系运算，返回结果是 class bool 类型
i = 1
j = 1
r = i < j
print(r)        # False
print(type(r))  # class bool
print("-----------------1-----------------")

# 整数的 `+`, `-` 运算
print(1 + 1)        # 2

# 整数的 `*` 运算
print(1 * 2)        # 2

# 整数的 `//`, `%` 运算
print(-1 // 12)   # -1, floordiv
print(-1 % 12)    # 11, floormod

print("-----------------2-----------------")
# 整数 -> 浮点数，numeric promotion.

# 浮点数的 `+`, `-` 运算
print(1.1 + 1.1)  # 2.2
# 浮点数的 `*` 运算
print(1.1 * 2)    # 2.2
# 浮点数的 `//`, `%` 运算
print(57.123 // 12)  # 4.0
print(57.123 % 12)   # 9.122999999999998

print(-57.123 // 12)  # -5.0, floor语义
print(-57.123 % 12)   # 2.8770000000000024, floor语义

print("-----------------3-----------------")

# `/` 运算
# 1. 如果操作数是整数，先转换成浮点数
print(1 / 2)       # 0.5, 1.0/2.0
print(1.0 / 2.0)   # 0.5
print(-57.123 / 12)  # -4.76025

print("-----------------4-----------------")


# 计算一个数字的平方跟
# 整数16转换成双精度浮点数16.0(整数值16被精确存储)，对16.0开方得到4.0
print(math.sqrt(16))  # 4.0
numb = 10009998
# 整数10009998转换成双精度浮点数10009998.0(整数值10009998被精确存储)，对10009998.0开方得到3163.8580878414885_061012373236226
print(math.sqrt(numb))  # 3163.8580878414887, 浮点数存储舍入: print(3163.8580878414885061012373236226)  # 3163.8580878414887

print("-----------------5-----------------")

# 怎么能够截断或者舍去浮点数的小数部分
# 1. math.trunc截断函数 (等同于将浮点数转换成整数)
print(math.trunc(12.45))  # 12
print(math.trunc(-12.456))  # -12
# 18014398509481984, 此双精度浮点数的整数部分超过 2^54-1, 存储时整数部分精度丢失，使用trunc函数得到的整数是精度丢失之后的值
print(math.trunc(18014398509481985.45))


